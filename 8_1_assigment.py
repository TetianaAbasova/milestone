# -*- coding: utf-8 -*-
"""8_1_assigment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/116H2z7dDU5_2p9q0W5NkJYxwgepr5o5b

# Assignment 8.1

> Replace all TODOs with your code.
>
> Do not change any other code and do not add/remove cells!

## Classes

### Task 1

Define a Python class named `Interval` with the following specifications:

1. The class should have a constructor (\_\_init__) that takes two parameters, start and end, and initializes the interval with these values.
2. Ensure that both start and end are numeric (either integers or floats).
3. Ensure that the start value is less than or equal to the end value.
4. Provide a \_\_str__ method to return a string representation of the interval in the format "[start, end]".
"""

class Interval:
    def __init__(self, start, end):
      try:
        self.start = float(start)
        self.end = float(end)
      except ValueError:
        raise ValueError("write the number")

      if self.start > self.end: # check start <= end
        raise ValueError("the starting value is NOT less than or equal to the ending value.")


    def __str__(self):
      return f"[{self.start}, {self.end}]"

interval = Interval(1, 5)
print(interval) # [1, 5]

"""### Task 2

Expand the Interval class by adding a method named `is_overlapping` that checks whether the current interval overlaps with another interval. The method should take another Interval object as a parameter and return `True` if there is an overlap and `False` otherwise.
"""

class Interval:
    def __init__(self, start, end):
      try:
        self.start = float(start)
        self.end = float(end)
      except ValueError:
        raise ValueError("write the number")

      if self.start > self.end: # check start <= end
        raise ValueError("the starting value is NOT less than or equal to the ending value.")


    def __str__(self):
      return f"[{self.start}, {self.end}]"


    # TODO
    def is_overlapping(self, other_interval):
        if self.start > other_interval.end or self.end < other_interval.start:
            return False
        else:
            return True


interval1 = Interval(1, 5)
interval2 = Interval(3, 8)

overlap_result = interval1.is_overlapping(interval2)
print("Do intervals overlap?", overlap_result) # Do intervals overlap? True

"""### Task 3

Expand the `Interval` class by adding a **static** method named `intersection_static` that calculates the intersection of two overlapping intervals. The static method should take two `Interval` objects as parameters and return a new `Interval` representing the intersection if there is one.

The method should return `None` if the intervals do not overlap.
"""

class Interval:
    def __init__(self, start, end):
      try:
        self.start = float(start)
        self.end = float(end)
      except ValueError:
        raise ValueError("write the number")

      if self.start > self.end: # check start <= end
        raise ValueError("the starting value is NOT less than or equal to the ending value.")


    def __str__(self):
      return f"[{self.start}, {self.end}]"


    # TODO
    @staticmethod
    def intersection_static(interval1, interval2):
        if interval1.start > interval2.end or interval1.end < interval2.start:  # do not intersect
            return None

        # #Variant 1
        # if interval1.start > interval2.start:
        #     result_start = interval1.start
        # else:
        #     result_start = interval2.start

        # if interval1.end < interval2.end:
        #     result_end = interval1.end
        # else:
        #     result_end = interval2.end

        #Variant 2
        result_start = max(interval1.start, interval2.start)
        result_end = min(interval1.end, interval2.end)

        return Interval(result_start, result_end)

interval1 = Interval(1, 5)
interval2 = Interval(3, 8)

intersection_result_static = Interval.intersection_static(interval1, interval2)
print("Intersection result (static method):", intersection_result_static) # Intersection result (static method): [3, 5]

"""### Task 4

Expand the `Interval` class by overloading a math operator "&" to calculate the intersection of two overlapping intervals. Define the logic for the intersection using the method from the previous task.
"""

class Interval:
    def __init__(self, start, end):
      try:
        self.start = float(start)
        self.end = float(end)
      except ValueError:
        raise ValueError("write the number")

      if self.start > self.end: # check start <= end
        raise ValueError("the starting value is NOT less than or equal to the ending value.")


    def __str__(self):
        return f"[{self.start}, {self.end}]"


    @staticmethod
    def intersection_static(interval1, interval2):
        if interval1.start > interval2.end or interval1.end < interval2.start:  # do not intersect
            return None

        result_start = max(interval1.start, interval2.start)
        result_end = min(interval1.end, interval2.end)

        return Interval(result_start, result_end)


    # TODO
    def __and__(self, other):
        try:
            return self.intersection_static(self, other)
        except ValueError:
            raise TypeError("The '&' operator is only available for Interval")


interval1 = Interval(1, 5)
interval2 = Interval(3, 8)

intersection_result = interval1 & interval2
print("Intersection result:", intersection_result) # Intersection result: [3, 5]

"""### Task 5

Expand the `Interval` class by adding a static method named `union_static` that calculates the union of two overlapping intervals. The static method should take two Interval objects as parameters and return a new Interval representing the union if there is one.

The method should return `None` if the intervals do not overlap.
"""

class Interval:
    def __init__(self, start, end):
      try:
        self.start = float(start)
        self.end = float(end)
      except ValueError:
        raise ValueError("write the number")

      if self.start > self.end: # check start <= end
        raise ValueError("the starting value is NOT less than or equal to the ending value.")


    def __str__(self):
        return f"[{self.start}, {self.end}]"


    # TODO
    @staticmethod
    def union_static(interval1, interval2):
        if interval1.end < interval2.start or interval2.end < interval1.start:
            return None

        result_start = min(interval1.start, interval2.start)
        result_end = max(interval1.end, interval2.end)

        return Interval(result_start, result_end)


interval1 = Interval(1, 5)
interval2 = Interval(3, 8)

union_result_static = Interval.union_static(interval1, interval2)
print("Union Result (Static method):", union_result_static) # Union Result (Static method): [1, 8]

"""### Task 6

Expand the `Interval` class by overloading a math operator "|" to calculate the union  of two overlapping intervals. Define the logic for the union using the method from the previous task.
"""

class Interval:
    def __init__(self, start, end):
      try:
        self.start = float(start)
        self.end = float(end)
      except ValueError:
        raise ValueError("write the number")

      if self.start > self.end: # check start <= end
        raise ValueError("the starting value is NOT less than or equal to the ending value.")


    def __str__(self):
        return f"[{self.start}, {self.end}]"


    @staticmethod
    def union_static(interval1, interval2):
        if interval1.end < interval2.start or interval2.end < interval1.start:
            return None

        result_start = min(interval1.start, interval2.start)
        result_end = max(interval1.end, interval2.end)

        return Interval(result_start, result_end)

    # TODO

    def __or__(self, other):
        return Interval.union_static(self, other)


interval1 = Interval(1, 5)
interval2 = Interval(3, 8)

union_result = interval1 | interval2
print("Union Result:", union_result) # Union Result: [1, 8]

"""### Task 7 (optional)

Expand the `Interval` class by overloading the "-" operator to calculate the difference between two intervals. The method should return a new `Interval` representing the portion of the first interval that is not in the second.
"""

class Interval:
    # TODO: copy methods from the tasks before

    # TODO


interval1 = Interval(1, 5)
interval2 = Interval(3, 8)

print("Difference Result:", interval1 - interval2) # Union Result: [1, 2]
print("Difference Result:", interval2 - interval1) # Union Result: [6, 8]